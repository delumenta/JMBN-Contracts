<script>
// ===== SG timezone formatting (add once near your helpers) =====
const SG_FMT = new Intl.DateTimeFormat('en-SG', {
  timeZone: 'Asia/Singapore', year: 'numeric', month: 'short', day: '2-digit',
  hour: '2-digit', minute: '2-digit'
});
function sgDateTime(iso){ return iso ? SG_FMT.format(new Date(iso)) : 'TBA'; }
const CLEAN = s => (s || '').trim().toLowerCase();
const IS_ONGOING_STATUS = s => (s==='planned' || s==='active');

// ===== Render helpers =====
function missionCardHtml(m, tally, mineSet, elevated){
  const id = m.id;
  const ts = m.start_time ? new Date(m.start_time) : null;
  const when = ts ? sgDateTime(m.start_time) : 'TBA';
  const going = mineSet?.has(id);
  const rsvpBtn = `
    <button class="btn rsvp-btn" data-id="${id}" data-state="${going?'going':'not'}" style="margin-left:6px">
      ${going ? 'Withdraw' : 'I’m going'}
    </button>`;
  const count = Number(tally[id] || 0);
  const editLink = elevated ? ` &nbsp;·&nbsp; <a class="inline" href="mission-editor.html?id=${id}">Edit</a>` : '';
  const countdown = ts ? `<span class="countdown" data-ts="${ts.toISOString()}">—</span>` : '<span class="countdown">TBA</span>';

  return `
    <div class="item">
      <h4>${esc(m.title || 'Untitled')}</h4>
      <div class="meta">
        ${esc(m.status || '')} • ${when} • ${countdown} •
        <span class="small">RSVP: <b class="rsvp-count" data-id="${id}">${fmt(count)}</b></span>
        ${rsvpBtn}
        &nbsp; · &nbsp;
        <a class="inline" href="mission-log.html">Open Mission Log</a>
        ${editLink}
      </div>
    </div>`;
}

// ===== Countdown driver (shared) =====
function startCountdownTicker(){
  function tick(){
    document.querySelectorAll('.countdown').forEach(el=>{
      const tsStr = el.getAttribute('data-ts');
      if(!tsStr){ el.textContent = 'TBA'; return; }
      const ts = new Date(tsStr).getTime();
      const diff = ts - Date.now();
      if(diff <= 0){ el.textContent = 'Started'; return; }
      const d = Math.floor(diff/86400000);
      const h = Math.floor((diff%86400000)/3600000);
      const m = Math.floor((diff%3600000)/60000);
      el.textContent = `${d}d ${h}h ${m}m`;
    });
  }
  tick();
  if(!window.__jmbnCountdown){
    window.__jmbnCountdown = setInterval(tick, 60000);
  }
}

// ===== RSVP helpers =====
async function getRsvpCounts(sb, ids){
  if(!ids.length) return {};
  // Pull all rows for these missions and tally client-side
  const { data, error } = await sb
    .from('mission_attendees')
    .select('mission_id')
    .in('mission_id', ids);
  if(error){ console.warn('RSVP counts:', error.message); return {}; }
  const tally = {};
  (data||[]).forEach(a => { tally[a.mission_id] = (tally[a.mission_id]||0) + 1; });
  return tally;
}

async function getMineRsvps(sb, userId, ids){
  if(!ids.length) return new Set();
  const { data, error } = await sb
    .from('mission_attendees')
    .select('mission_id')
    .eq('user_id', userId)
    .in('mission_id', ids);
  if(error){ console.warn('Mine RSVPs:', error.message); return new Set(); }
  return new Set((data||[]).map(x=>x.mission_id));
}

async function toggleRsvp(sb, missionId, userId, currentState){
  if(currentState === 'going'){
    await sb.from('mission_attendees')
      .delete()
      .eq('mission_id', missionId)
      .eq('user_id', userId);
  }else{
    await sb.from('mission_attendees').insert({ mission_id: missionId, user_id: userId });
  }
  // Refresh count (cheap head-count)
  const { count } = await sb
    .from('mission_attendees')
    .select('mission_id', { count: 'exact', head: true })
    .eq('mission_id', missionId);
  const cEl = document.querySelector(`.rsvp-count[data-id="${missionId}"]`);
  if(cEl) cEl.textContent = fmt(count || 0);
  const btn = document.querySelector(`.rsvp-btn[data-id="${missionId}"]`);
  if(btn){
    const next = currentState === 'going' ? 'not' : 'going';
    btn.dataset.state = next;
    btn.textContent = next === 'going' ? 'Withdraw' : 'I’m going';
  }
}

// ===== Bucketize & render =====
function bucketizeForDashboard(rows){
  const now = Date.now();
  const SIX_HR = 6*3600*1000;
  const ONE_DAY = 24*3600*1000;
  const ongoing = [];
  const upcoming = [];

  for(const m of rows){
    if(!IS_ONGOING_STATUS(CLEAN(m.status))) continue;
    if(!m.start_time) continue; // must have a date to appear on dashboard buckets
    const ts = new Date(m.start_time).getTime();
    if(Number.isNaN(ts)) continue;
    if(ts >= now - SIX_HR && ts <= now + ONE_DAY) ongoing.push(m); // "Ongoing now" window
    if(ts > now) upcoming.push(m);                                  // Future only
  }
  ongoing.sort((a,b)=>new Date(a.start_time)-new Date(b.start_time));
  upcoming.sort((a,b)=>new Date(a.start_time)-new Date(b.start_time));
  return { ongoing, upcoming };
}

function renderEventsBox(boxEl, ongoing, upcoming, tally, mineSet, elevated){
  const parts = [];
  // Ongoing now
  parts.push(`<div style="margin-bottom:6px"><span class="badge">Ongoing now</span></div>`);
  if(ongoing.length){
    parts.push(ongoing.map(m => missionCardHtml(m, tally, mineSet, elevated)).join(''));
  }else{
    parts.push(`<div class="empty">No missions currently within the window.</div>`);
  }

  // Upcoming
  parts.push(`<div style="margin:10px 0 6px"><span class="badge">Upcoming</span></div>`);
  if(upcoming.length){
    parts.push(upcoming.map(m => missionCardHtml(m, tally, mineSet, elevated)).join(''));
  }else{
    parts.push(`<div class="empty">No future missions scheduled.</div>`);
  }

  boxEl.innerHTML = parts.join('');
  startCountdownTicker();

  // wire RSVP buttons
  boxEl.querySelectorAll('.rsvp-btn').forEach(btn=>{
    btn.onclick = () => toggleRsvp(sb, btn.dataset.id, session.user.id, btn.dataset.state);
  });
}

// ===== REPLACEMENT: loadEvents() with buckets + RSVP + SG TZ + Realtime =====
async function loadEvents(){
  const box = document.querySelector('#events');
  if(!box) return;
  box.innerHTML = '<div class="empty">Loading…</div>';

  try{
    // Pull *recent and future* missions and filter client-side for status
    // Wider window ensures ongoing bucket can include already-started missions
    const sinceISO = new Date(Date.now() - 48*3600*1000).toISOString(); // 48h lookback to be safe
    const { data, error } = await sb
      .from('missions')
      .select('id,title,status,start_time')
      .or(`start_time.gte.${sinceISO},start_time.is.null`) // keep nulls out of buckets but harmless to fetch
      .order('start_time', { ascending: true })
      .limit(100);
    if(error) throw error;

    const rows = (data||[]).filter(m => IS_ONGOING_STATUS(CLEAN(m.status)));
    const { ongoing, upcoming } = bucketizeForDashboard(rows);

    const ids = [...new Set([...ongoing, ...upcoming].map(m => m.id))];
    const [tally, mineSet] = await Promise.all([
      getRsvpCounts(sb, ids),
      getMineRsvps(sb, session.user.id, ids)
    ]);

    // determine elevation (you already computed earlier; reusing if available)
    let elevated = false;
    try{ const { data: elev } = await sb.rpc('is_elevated', { u: session.user.id }); elevated = !!elev; }catch(_){}

    renderEventsBox(box, ongoing, upcoming, tally, mineSet, elevated);

    // Realtime: missions and RSVPs
    if(!window.__jmbnRealtimeEvents){
      window.__jmbnRealtimeEvents = sb.channel('rt-events')
        .on('postgres_changes', { event: '*', schema: 'public', table: 'missions' }, () => loadEvents())
        .on('postgres_changes', { event: '*', schema: 'public', table: 'mission_attendees' }, () => loadEvents())
        .subscribe();
    }
  }catch(e){
    box.innerHTML = `<div class="empty" style="color:var(--bad)">Failed: ${esc(e.message)}</div>`;
  }
}
</script>
